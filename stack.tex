\chapter{栈}
\label{cha:algo-stack}

\section{进栈出栈}

栈是一种\uline{连续}据构，数据在栈内连续存储。栈有栈顶和栈底类似链
表的首部和尾部，区别是栈在垂直上下方向生长，链表在水平左右向生长。
如果需要，我们也可以用水平示意图表示栈，左边是栈底，往右生
长，如数组模拟栈就是这种思路。C/C++ 内存中的栈区即是一种栈结构。

给定一有 n 个元素的\uline{有序序列} $a_1, a_2, \cdots, a_n$, 对栈有
两种基本操作：\uline{进栈 push} 和\uline{出栈 out}. 无论是进栈还是
出栈，都是对栈顶进行操作。进栈也称压栈，表示保持元素间相对顺序把元
素存到栈顶，而出栈则表示取出栈顶的元素。

进栈、出栈组成一个\uline{动态操作序列}，在 $n$ 个元素依次进栈的过程
中，伴随着元素随机出栈。动态操作序列有 $2n$ 个步骤，其中 $n$个
是进栈操作，另 $n$ 个是出栈操作。进出栈操作结束，栈为空，进栈的
$n$ 个元素亦全部出栈。

进栈顺序事先给定，用下标 $i$ 表示，表示为 $a_i,\; i \in
\{1,2,\cdots,n\}$. 出栈序列是进栈序列的某种排列，可记为
$a_{j_l},\; j_l \in \{1,2,\cdots,n\},\; l \in
\{1,2,\cdots,n\}$. $a_i$ 进栈操作和 $a_{j_l}$ 出栈操作\uline{相间
  出现}。$2n$ 个动态操作序列可记成：

\begin{align*}
  c_k,\; k \in \{1,2,\cdots,2n\},\; c_k\; \text{是}\; a_i\;
  \text{进栈或}\; a_{j_l}\; \text{出栈}
\end{align*}

可以肯定 $c_1$ 肯定代表 $a_1$ 进栈，$c_{2n}$ 表示某元素出栈。

实际上给定一个完整的出栈序列 $a_{j_l}$ 我们可以还原进出栈操作序列
$c_k$, 所以通常只需出栈序列 $a_{j_l}$ 即可。给出进栈序列 $a_i$ 在
$c_k$ 中的位置，我们可以推出剩下 n 个位置的出栈序列 $a_{j_l}$.

\section{先进后出}

进栈出栈遵循\textbf{先进后出，后进先出}的原则。对于\uline{当前栈内}元
素，后进栈的圧在先进栈的上边，栈顶永远是当前最后一个进栈元素，所以
先进栈的肯定比后进栈的后出栈，或说后进栈的肯定比选进栈的先出栈。换
句话说，任一时刻，栈的状态决定了当前栈内元素的相对出栈顺序。

总结起来，进出栈序列 $c_k$ 满足：
\begin{itemize}
\item $a_i$ 间的相对位置固定，因为进栈顺序事先给定。
\item $a_i$ 和 $a_{j_l}$ 符合先进后出。
\end{itemize}

可以看出，上面说的进栈出栈，不是指所有 n 个元素全部一次性入栈，再一
次性出栈。实际过程是进栈、出栈两种操作是交替进行，只要栈不为空，就
有可能进行出栈操作。如 $a_1, a_2$ 依次入栈（栈顶到底依次是 $a_2,
a_1$, 所以 $a_2$ 肯定比 $a_1$先出栈），接着 $a_2$ 立即出栈，$a_3$
入栈（栈内依次是 $a_3, a_1$，所以 $a_3$ 肯定比 $a_1$ 先出栈）。

前对对进出栈过程分析的比较清楚，任一时刻的栈内元素符合先进后
出原则。那么此原则是如何体现在完整操作序列 $c_k$ 里的呢？

\textbf{出栈序列里任一元素 $a_{j_l}$, 比其后出且先进的元素倒序。
  这些元素排在 $a_{j_l}$ 后面（后出栈），而且下标比 ${j_l}$ 小（先
  进栈）。它们（包括 $a_{j_l}$ 在内）一定是按下标降序排列}！

我们可以据此判断一个出栈序列是否正确。如 $3,4,5,1,2,9,8,7,6$ 是出栈
序列的下标 $j_l$, 显然这个出栈序列不正确，因为出现了 $3,1,2$. 存在
某个栈状态，$3$ 圧在 $1$ 和 $2$ 上面，栈内元素由上到下依次
是 $3,2,1$.

为了便于运算，我们一般用下标直接代替元素本身！在验证时，我们遍历
$j_l$, 从其开始，后面比其小的是否全部降序。由上例，$4,1,2$ 和
$5,1,2$ 都不合法。

\section{栈深度最小值}

给出出栈序列 $a_{j_l}$, 问栈深度最小值是多少。

在进出栈动态操作过程中，元素或进栈或出栈，栈内元素个数不定。栈需容
纳未出栈元素。如果每进栈一次，再出栈一次，则栈深度只需 1 即可。如
果所有元素全部入栈再出栈，则栈深度最少为 n.

对于一般情况，该如何算呢？其实很简单，只需利用上面的降序原则。遍历
出栈序列，对 $a_{j_l}$, 数出从其开始往后，降序元素个数（包含
$a_{j_l}$），最大值即为栈的最小深度。

\section{出栈序列数}

出栈序列数是指，给出进栈序列 $a_i$, 有多少种出栈序列 $a_{j_l}$?

操作序列 $c_k$ 有 2n 个位置，一旦确定了进栈序列 $a_i$ 的 n 个位置，
则立马得到出栈序列。也可以选出 n 个位置作为出栈序列，但是出栈序列内
部还有先后问题，所以用前一种思路更好。

从 $2n$ 个位置中选取 n 个的方法数是组合数 $C_{2n}^n$, 但进栈序列的
选位方法数比这小。如 $a_1$ 进栈肯定在第 1 位，而且 $a_i$ 肯定不能
排在最后 n 个位置。所以最终的方法数肯定是 $C_{2n}^n$ 除以或减去某
个数。

如果对进出栈计数，用 $+1$ 表示一次进栈，$-1$ 表示一次出栈，则任何时
候栈内元素个数就是这些 $\pm 1$ 的和。显然，任一时刻，栈内元素不能是
负数个，入栈次数肯定\uline{不少于}出栈次数，$+1$ 个不小于 $-1$ 个
数，$\pm 1$ 的和 $\geqq 0$.

对应到 $c_k,\; k \in \{1,2,\cdots,2n\}$ 序列，从头至尾扫描（水平示
意图），对 k 编历, 对任意 k, 前 k 个位置里，$+1$ 个数不少于 $-1$ 个
数。进出栈操作完毕，$n$ 个 $+1$ 和 $n$ 个 $-1$ 总和为 0. 有时为了方
便，直接用 $\pm$ 表示即可。有的地方用 $+1$ 和 $0$ 分别表示进栈、
出栈，最后的 $C_k$ 是一个二进制数。

总结起来是，\textbf{进出栈序列 $C_k$ 的所有前缀子串皆满足 $+1$ 个
  数不小于（大于等于） $-1$ 个数}。

特别地，当 $k = 1$ 时，前 1 位只能是 $a_1$ 进栈，和加 1 为 1. 当 $k
= 2n$ 时，最后 1 位是某元素出栈，和减 1 为 0.

所以我们要在 $C_{2n}^n$ 的基础上排除和为负的情况，也即在栈为空时或
为负时，进行出栈操作，也即在遍历 k 的过程中遇到和为负数情况。

假设在遍历 k 的过程中，第 1 次遇到和为 $-1$ 时，
有 m 个 $-1$, 则$+1$为 $m - 1$ 次，此时
$k = 2m - 1,\; m \in \{1,2,\cdots,n\}$. 显然 k是奇数，m 最大值
是 n. 特别地，第 k 位是 $-1$, 前面 $2m - 2$ 位中，分别有 $m -
1$ 位 $+1$ 和 $-1$. 后面 $2n-k$ 位里面有 $n - m +
1$ 个 $+1$, 剩下 $n - m$ 位是 $-1$.

对于奇数 k, 非法方法数是不是

\[
  C_{2m-2}^{m-1}C_{2n-(2m-1)}^{n-(m-1)} =
  C_{2m-2}^{m-1}C_{2n-(2m-1)}^{n-m}
\]

呢？此式表示前 $2m - 2$ 个位置里选 $m - 1$ 个出来放 $+1$ 表示进栈，
剩下的 $2n - (2m - 1)$ 个位置里选 $n - (m - 1)$ 个放剩下的
$+1$. 从 $-1$ 的角度分析，结果是
$C_{2m-2}^{m-1}C_{2n-(2m-1)}^{n-m}$. 答案是否定得！因为这种选取方
法不能保证前面 $k - 1$ 位里不出现和为负的情况。

我们可以换个思路。第 1 次遇到和为 $-1$ 时，后面 $2n-k$ 位的和
是$+1$，即进栈次数比出栈多 1. 如果交换后面的 $\pm 1$, 则可以得到一
个满射，组合计数不变。交换后面的 $\pm 1$ 后，$2n$ 位里面有 $n +
1$个 $-1$ 和 $n - 1$ 个 $+1$, 总和为 $-2$, 出栈比进栈多 2 次。反过
来，总和为 $-2$ 时总能找到第 1 次和为 -1 的情况。所以总的非法进出
栈方法数是 $C_{2n}^{n+1} = C_{2n}^{n-1}$, 那么合法进出栈总数为：

\begin{align*}
  C_{2n}^n - C_{2n}^{n+1} = \frac{C_{2n}^n}{n+1}
\end{align*}

这其实是一个卡特兰数~\ref{cha:catalan-number}.

至此，我们从组合数的角度直接得出进栈数序列数为卡特兰数。进出栈序操
作序列，对应对组合数学问题，是在 $2n$ 个位置上，选取 n 个放 $+1$ 或
$-1$, 要求是对位置 k 遍历，和为非负整数。

\section{进出栈递推方法}

下面我们从递推方法分析进出栈问题。分析算法问题时，我们可以找出问题
不同规模之间的联系，具体点就是递推关系。在算法领域，初始条件非常重
要。同一公递推公式的因为不同的初始条件而产生不同的数列。

用 f(n) 表示出栈序列数。先看进出栈的小规模问题。明显 $f(1) = 1$,
只有 1 个元素 $a_1$ 时，其进栈再出栈，只有一种可能。对于 $f(2) =
2$ 时：

\begin{enumerate}
\item 第一种是 $a_1$ 进，$a_1$ 出，$a_2$ 进，$a_2$ 出：$+-+-$
\item 第二种是 $a_1$ 进，$a_2$ 进，$a_2$ 出，$a_1$ 出：$++--$
\end{enumerate}

当 $n > 2$ 时，我们就要抽象分析了。分析有两个思路。第一种是考虑 n 个
元素里，哪个最先出栈，也即出栈序列里，谁是第 1 个元素。第二种是考虑
第 1 个元素 $a_1$ 出栈时所在位置，也即 $a_1$ 在出栈序列排第几位。我
们先看第一种思路。

\subsection{最先出栈元素}

如果是 $a_1$ 最先出栈，则出栈序列是 $a_1, a_{j_l},\; j_l \in
\{2,3,\cdots,n\}$. 很明显，$c_k$ 前两位是 $+-$, 表示 $a_1$ 进栈后立
马出栈。$a_1$ 进栈、出栈后不影响其后元素的进出栈，因为后面 $n - 1$
个元素根本还没入栈，这是一个 $n - 1$ 规模的子问题，有 $f(n - 1)$ 种
可能。

如果是 $a_2$ 最先出栈。此时其前元素 $a_1$ 已入栈并且没出栈。同
理 $a_2$ 最先出栈不影响后面元素 $a_i, i \in \{3,4,\cdots,n\}$ 的出栈序
列，因为后面元素根本还没入栈。其后元素有 $f(n - 2)$ 种可能出栈序列。
其前面的 $a_1$ 穿插于其后元素出栈序列之间。

对于一般情况，$a_k, k \in \{1,2,\cdots,n\}$ 最先出栈。此时
$a_i, i \in \{1,2,\cdots,k-1\}$ 已入栈并且没出栈。由前面分析可知，
这 $k - 1$ 个元素元素下标比 k 小（先进栈），但比 $a_k$ 后出栈，在出
栈序列里必须是（相对）降序排列（包括 $a_k$ 在内），即 $a_k,
a_{k-1},\cdots,a_1$. 因为在 $a_k$ 先出栈的条件下，从栈顶到栈底依次
是 $a_{k-1},a_{k-2},\cdots,a_1$. 特殊的，如果 $k = n$, 则 $a_n$ 最先
出栈，说是所有 n 个元素依次全部进栈，然后依次倒序出栈。

对于下标比 k 大的元素而言，$a_k$ 最先出栈不影响 $a_i, i \in
\{k+1,k+2,\cdots,n\}$ 出栈。后面元素的出栈是规模为 $n - k$ 的子问
题，有 $f(n - k)$ 种可能。

这个一般情况有多少种可能呢？考虑出栈序列
$a_k, a_{j_l},\; j_l \neq k, j_l \in \{1,2,\cdots,n\}$. 除了第 1
位 $a_k$, 余下 $n - 1$ 位里先选 $k - 1$ 个出来按序放 $a_{k-1},
a_{k-2}, \cdots, a_1$. 余下的 $n - k$ 位是 $a_i,\; i \in
\{k+1,k+2,\cdots,n\}$ 的出栈序列，对应序列数是 $f(n - k)$. 所以最
终是是：

\begin{align*}
C_{n-1}^{k-1}f(n-k) = C_{n-1}^{n-k}f(n-k),\; k \in \{1,2,\cdots,n\}
\end{align*}

为保证定义完备性，当 $k = n$ 时，我们定义 $f(n-n) = f(0) = 1$. 所
以 $a_i,\; i \in \{1,2,\cdots,n\}$ 的出栈序列数是：

\begin{align*}
  f(n) &= \sum_{k = 1}^nC_{n-1}^{n-k}f(n-k) = \sum_{k=1}^n C_{n-1}^{k-1}f(n-k) \\
  f(1) &= f(0) = 1
\end{align*}

\textbf{很可惜这个结果是错的}！乘法原理要求相乘的两个部分没有交集。
上面的分析里，保证了后面 $n - k$ 个元素的出栈相对序列，也保证了前
面 $k - 1$ 个元素倒序出栈，但当两个部分合在一起时，用乘法原理时，有
部分不符合要求。如 $a_k,a_{n-1},a_2,a_1,a_{n-3},\cdots$ 这个出栈序
列里，$a_k$ 前面的 $a_2,a_1$ 保持了降序，$a_k$ 后面
的$a_{n-1},a_{n-3}$ 是子问题，但是合在一起
时，$a_{n-1},a_2,a_1,a_{n-3}$ 这 4 个元素不是严格降序。

虽然这个分析错误，但能加强我们对进出栈问题的理解。

\subsection{$a_1$ 出栈位置}

下面从最先入栈的元素 $a_1$, 也即第 1 个元素出栈序号入手分析问题。
设 $a_1$ 第 $k,\; k \in \{1,2,\cdots,n\}$ 位出栈，则
在 $a_1$ 前有 $k - 1$ 个元素出栈，$a_1$ 后有 $n - k$ 个元素出栈。

可以肯定，$a_1$ 第 k 位出栈时，栈刚好为空，表明有 k 个元素入栈并完
全出栈。那么这 $k - 1$ 个元素是哪些呢？$a_1$ 第 1 位入栈后，有 $k
- 1$ 个元素先入进出栈，$a_1$ 等这些元素出栈后才最后出栈。明显这 $k
- 1$ 个元素就是 $a_i,\; i \in \{2,3,\cdots,k-1\}$.

假设 $a_l,\; k \leq l \leq n$ 在前 $k$ 个出栈元素中。
若 $a_l$ 在第 1 位出栈，据上一小节思路，这 k 个位置显然放不
下 $a_l, a_{l-1},\cdots,a_1$ 这 l个元素。若 $a_l$ 在第 2 位，
则 $a_l$ 和 $a_1$ 间的距离更短了，而且此时第 1 位是比 $a_l$ 更靠后
的元素了，同样容不下那么多元素。

以 $k = 2$ 为例, $a_1$ 出栈前要等 1 个元素先出栈。这个元素只能
是 $a_2$. 假假是 $a_3$, 则出栈序列是 $a_3,a_1,\cdots$, 显然中间
的 $a_2$ 没有正确出栈。从另一个角度看，$a_3$ 第 1 个出栈，这个序列
没有保证 $a_3,a_2,a_1$ 间相对降序出栈。因此 $a_1$ 等的不可能
是 $a_2$ 后的任何元素。

这 k 个元素的进出栈是一个完整的子问题，最先入栈的最后出栈。由于
第 k 位确定为 $a_1$, 则规模为 $k - 1$. 方法数是 $f(k - 1)$.

在 $a_1$ 后面进出栈的元素是 $a_i,\; i \in \{k+1,k+2,\cdots,n\}$ 这
$n - k$ 个元素。通过上面分析得，$a_1$ 在第 k 位出栈时，其前 $k -
1$ 个元素和后 $n - k$ 个元素的进出栈序列完全独立，互不影响。后面
$n - k$ 个元素的进出栈也是一个完整的子问题，规模为 $n - k$, 方法数
是 $f(n - k)$.

根据乘法原理，$a_1$ 第 k 位出栈时，方法数为 $f(k - 1)f(n - k)$. 由
此 n 个元素的进出栈方法数是：

\begin{align*}
  f(n) &= \sum_{k=1}^n f(k - 1)\,f(n - k) \\
  f(0) &= 1
\end{align*}

此公式就是卡特兰数~\ref{cha:catalan-number}~的递推公式。不像上节，
这节分析没有错误。两个子问题的进出栈序列集合交集为空，符合合乘法原
理。

不难发现，进出栈动态操作过程中，一旦栈为空，就得到一个规模更小的完
整子问题。进出栈问题，可以分成很多小的子问题，这此子问题问互不影响。
特别地，当出栈序列为 $a_1,a_2,\cdots,a_n$ 时，每一步出栈操作都定义
了一个子问题，规模为 1, 一共有 n 个子问题. 任意 k, $a_k$ 进栈再出栈
时栈为空，构成一个进出栈子问题。

前面分析中，在给出 $a_1$ 出栈得到两个子问题，刚好互逆，并集是进出栈序列的全集。
对这两个子问题，我们还可以分成规模更小的子问题。这是从已知结果前提
下，一个递归分解过程。

另外，在出栈序列里，若 $a_1$ 所在位置为 k, 可以肯定 $a_1$ 前的元素
必须是 $a_i,\; i \in \{2,3,\cdots,k-1\}$. 同理，$a_1$ 后的元素肯定
是 $a_i,\; i \in \{k+1,k+2,\cdots,n\}$. 如果出现超出此范围的元素，
则出栈序列非法。由此也可以快速排除一个非法的出栈序列。不过，这只是
进出栈序列的一个必要非充分条件，不能用来找出正确出栈序列。

\subsection{递归编程}

进出栈问题里，栈的状态可以由两个参数表示，特入栈元素（栈外）个数 n
和栈内元素个数 k, n 和 k 组成一个有序队 $(n,k)$, 我们用符
号 $f(n,k)$ 表示进出栈操作序列。下一步可以进栈 $f(n-1,k+1)$, 也可以
是出栈 $f(n,k-1)$. 显然 $k = 0$ 时不能出栈。

$f(n,0)$ 表示初始状态，$f(0,0)$ 表示操作结束。用此思路，我们可以用
递归函数 $f(n,k)$ 列出所有进出栈序列。

\section{进出栈总结}

\begin{enumerate}
\item 进出栈序列串，任意前缀子串满足 $+1$ 个数不小于 $-1$ 个数。
\item 出栈序列串，任意 k, 下标比 k 小的并排 $a_k$ 后的元素，其下标
  降序。
\item 出栈序列串，$a_1$ 出栈时，左边是 $a_i,\; i \in
  \{1,2,\cdots,k-1\}$ 子问题, 右边是 $a_i,\; i \in
  \{k+1,k+2,\cdots,n\}$ 子问题。
\item 进出栈动态过程中，每次栈为空时，得到一个子问题，所有子问题合
  并是总问题。
\end{enumerate}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
